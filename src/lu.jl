# ------------------------------------------------------------------
# Licensed under the MIT License. See LICENSE in the project root.
# ------------------------------------------------------------------

@kwdef struct LUGP{V,T,F,C,I} <: GeoStatsProcess
  variogram::V = GaussianVariogram()
  mean::T = nothing
  factorization::F = cholesky
  correlation::C = 0.0
  init::I = NearestInit()
end

function randprep(::AbstractRNG, process::LUGP, setup::RandSetup)
  # retrieve setup paramaters
  (; domain, geotable, varnames, vartypes) = setup

  # check the number of variables
  @assert length(varnames) ‚àà (1, 2) "only 1 or 2 variables can be simulated simultaneously"

  # retrieve process parameters
  Œ≥ = process.variogram
  fact = process.factorization
  init = process.init

  # check stationarity
  @assert isstationary(Œ≥) "variogram model must be stationary"

  # initialize buffers for realizations and simulation mask
  vars = Dict(zip(varnames, vartypes))
  buff, mask = initbuff(domain, vars, init, data=geotable)

  # preprocess parameters for individual variables
  pairs = map(varnames) do var
    # retrieve data locations and data values in domain
    dlocs = findall(mask[var])
    z‚ÇÅ = view(buff[var], dlocs)

    # retrieve simulation locations
    slocs = setdiff(1:nelements(domain), dlocs)

    # create views of the domain
    ùíüd = [centroid(domain, i) for i in dlocs]
    ùíüs = [centroid(domain, i) for i in slocs]

    # covariance between simulation locations
    C‚ÇÇ‚ÇÇ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüs)

    if isempty(dlocs)
      d‚ÇÇ = zero(eltype(z‚ÇÅ))
      L‚ÇÇ‚ÇÇ = fact(Symmetric(C‚ÇÇ‚ÇÇ)).L
    else
      # covariance beween data locations
      C‚ÇÅ‚ÇÅ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüd)
      C‚ÇÅ‚ÇÇ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüd, ùíüs)

      L‚ÇÅ‚ÇÅ = fact(Symmetric(C‚ÇÅ‚ÇÅ)).L
      B‚ÇÅ‚ÇÇ = L‚ÇÅ‚ÇÅ \ C‚ÇÅ‚ÇÇ
      A‚ÇÇ‚ÇÅ = B‚ÇÅ‚ÇÇ'

      d‚ÇÇ = A‚ÇÇ‚ÇÅ * (L‚ÇÅ‚ÇÅ \ z‚ÇÅ)
      L‚ÇÇ‚ÇÇ = fact(Symmetric(C‚ÇÇ‚ÇÇ - A‚ÇÇ‚ÇÅ * B‚ÇÅ‚ÇÇ)).L
    end

    if !isnothing(process.mean) && !isempty(dlocs)
      @warn "mean can only be specified in unconditional simulation"
    end

    # mean for unconditional simulation
    Œº = isnothing(process.mean) ? zero(eltype(z‚ÇÅ)) : process.mean

    # save preprocessed parameters for variable
    var => (z‚ÇÅ, d‚ÇÇ, L‚ÇÇ‚ÇÇ, Œº, dlocs, slocs)
  end

  Dict(pairs)
end

function randsingle(rng::AbstractRNG, process::LUGP, setup::RandSetup, prep)
  # list of variable names
  vars = setup.varnames

  # simulate first variable
  v‚ÇÅ = first(vars)
  Y‚ÇÅ, w‚ÇÅ = _lusim(rng, prep[v‚ÇÅ])
  varreal = Dict(v‚ÇÅ => Y‚ÇÅ)

  # simulate second variable
  if length(vars) == 2
    œÅ = process.correlation
    v‚ÇÇ = last(vars)
    Y‚ÇÇ, _ = _lusim(rng, prep[v‚ÇÇ], œÅ, w‚ÇÅ)
    push!(varreal, v‚ÇÇ => Y‚ÇÇ)
  end

  varreal
end

function _lusim(rng, params, œÅ=nothing, w‚ÇÅ=nothing)
  # unpack parameters
  z‚ÇÅ, d‚ÇÇ, L‚ÇÇ‚ÇÇ, Œº, dlocs, slocs = params

  # number of points in domain
  npts = length(dlocs) + length(slocs)

  # allocate memory for result
  y = Vector{eltype(z‚ÇÅ)}(undef, npts)

  # conditional simulation
  w‚ÇÇ = randn(rng, size(L‚ÇÇ‚ÇÇ, 2))
  if isnothing(œÅ)
    y‚ÇÇ = d‚ÇÇ .+ L‚ÇÇ‚ÇÇ * w‚ÇÇ
  else
    y‚ÇÇ = d‚ÇÇ .+ L‚ÇÇ‚ÇÇ * (œÅ * w‚ÇÅ + ‚àö(1 - œÅ^2) * w‚ÇÇ)
  end

  # hard data and simulated values
  y[dlocs] = z‚ÇÅ
  y[slocs] = y‚ÇÇ

  # adjust mean in case of unconditional simulation
  isempty(dlocs) && (y .+= Œº)

  y, w‚ÇÇ
end
