# ------------------------------------------------------------------
# Licensed under the MIT License. See LICENSE in the project root.
# ------------------------------------------------------------------

"""
    LindgrenProcess(range=1.0, sill=1.0; init=NearestInit())

Lindgren process with given `range` (correlation length)
and `sill` (total variance) as described in Lindgren 2011.
Optionally, specify the data initialization method `init`.

The process relies relies on a discretization of the Laplace-Beltrami 
operator on meshes and is adequate for highly curved domains (e.g. surfaces).

## References

* Lindgren et al. 2011. [An explicit link between Gaussian fields and
  Gaussian Markov random fields: the stochastic partial differential
  equation approach](https://rss.onlinelibrary.wiley.com/doi/10.1111/j.1467-9868.2011.00777.x)
"""
struct LindgrenProcess{‚Ñí<:Len,V,I} <: FieldProcess
  range::‚Ñí
  sill::V
  init::I
  LindgrenProcess(range::‚Ñí, sill::V, init::I) where {‚Ñí<:Len,V,I} = new{float(‚Ñí),float(V),I}(range, sill, init)
end

LindgrenProcess(range=1.0u"m", sill=1.0; init=NearestInit()) = LindgrenProcess(addunit(range, u"m"), sill, init)

function randprep(::AbstractRNG, process::LindgrenProcess, ::DefaultRandMethod, setup::RandSetup)
  # retrieve setup paramaters
  (; domain, geotable, varnames, vartypes) = setup

  # retrieve sill and range
  ùìÅ = process.range
  œÉ = process.sill

  # retrieve initialization method
  init = process.init

  # sanity checks
  @assert domain isa Mesh "domain must be a `Mesh`"
  @assert ùìÅ > zero(ùìÅ) "range must be positive"
  @assert œÉ > zero(œÉ) "sill must be positive"

  # Laplace-Beltrami operator
  W = laplacematrix(domain)
  M = measurematrix(domain)
  Œî = inv(M) * W

  # retrieve parametric dimension
  d = paramdim(domain)

  # LHS of SPDE (Œ∫¬≤ - Œî)Z = œÑW with Œî = M‚Åª¬πW
  Œ± = 2
  ŒΩ = Œ± - d / 2
  Œ∫ = 1 / ùìÅ
  A = Œ∫^2 * I - Œî

  # Mat√©rn precision matrix
  œÑ¬≤ = œÉ^2 * Œ∫^(2ŒΩ) * (4œÄ)^(d / 2) * gamma(Œ±) / gamma(ŒΩ)
  Q = ustrip.(A'A / œÑ¬≤)

  # factorization
  F = cholesky(Array(Q))
  L = inv(Array(F.U))

  # initialize buffers for realizations and simulation mask
  pset = PointSet(vertices(domain))
  vars = Dict(zip(varnames, vartypes))
  buff, mask = initbuff(pset, vars, init, data=geotable)

  # result of preprocessing
  pairs = map(varnames) do var
    # retrieve buffer and mask for variable
    z = buff[var]
    m = mask[var]

    # retrieve data locations and data values
    i‚ÇÅ = findall(m)
    z‚ÇÅ = view(z, i‚ÇÅ)

    # retrieve simulation locations
    i‚ÇÇ = setdiff(1:nvertices(domain), i‚ÇÅ)

    # interpolate at simulation locations if necessary
    zÃÑ = if isempty(i‚ÇÅ)
      nothing
    else
      z[i‚ÇÇ] .= -Q[i‚ÇÇ,i‚ÇÇ] \ (Q[i‚ÇÇ,i‚ÇÅ] * z‚ÇÅ)
      z
    end

    # save preprocessed inputs for variable
    var => (; Q, L, i‚ÇÅ, i‚ÇÇ, zÃÑ)
  end

  Dict(pairs)
end

function randsingle(rng::AbstractRNG, ::LindgrenProcess, ::DefaultRandMethod, setup::RandSetup, prep)
  # retrieve setup paramaters
  (; domain, geotable, varnames, vartypes) = setup

  # simulation at vertices
  varreal = map(varnames, vartypes) do var, V
    # unpack preprocessed parameters
    (; Q, L, i‚ÇÅ, i‚ÇÇ, zÃÑ) = prep[var]

    # unconditional realization
    w = randn(rng, V, nvertices(domain))
    z·µ§ = L * w

    # perform conditioning if necessary
    z = if isempty(i‚ÇÅ)
      z·µ§ # we are all set
    else
      # view realization at data locations
      z·µ§‚ÇÅ = view(z·µ§, i‚ÇÅ)

      # interpolate at simulation locations
      zÃÑ·µ§ = similar(z·µ§)
      z·µ§‚ÇÇ = -Q[i‚ÇÇ,i‚ÇÇ] \ (Q[i‚ÇÇ,i‚ÇÅ] * z·µ§‚ÇÅ)
      zÃÑ·µ§[i‚ÇÅ] .= z·µ§‚ÇÅ
      zÃÑ·µ§[i‚ÇÇ] .= z·µ§‚ÇÇ

      # add residual field
      zÃÑ .+ (z·µ§ .- zÃÑ·µ§)
    end

    var => z
  end

  # vertex table
  vtable = (; varreal...)

  # change of support
  vdata = GeoTable(domain; vtable)
  edata = _integrate(vdata, varnames...)

  # columns of element table
  cols = Tables.columns(values(edata))
  Dict(var => Tables.getcolumn(cols, var) for var in varnames)
end

# -----------------
# HELPER FUNCTIONS
# -----------------

# Integrate geospatial `data` for variables `vars` over geometries of
# given `rank`. Default rank is the parametric dimension of the
# underlying geospatial domain.
function _integrate(t::AbstractGeoTable, vars...; rank=nothing)
  # domain and vertex table
  ùíü = domain(t)
  ùíØ = values(t, 0)

  valid = Tables.schema(ùíØ).names
  @assert vars ‚äÜ valid "invalid variables for vertex table"

  # vertices and topology
  vert = vertices(ùíü)
  topo = topology(ùíü)

  # retrieve columns
  cols = Tables.columns(ùíØ)
  vals = [Tables.getcolumn(cols, var) for var in vars]

  # rank of integration
  R = isnothing(rank) ? paramdim(ùíü) : rank

  # loop over faces
  table = map(faces(topo, R)) do face
    # perform integration of all variables
    ints = _integrateface(face, vert, vals)

    # row of table with results
    (; zip(vars, ints)...)
  end

  GeoTable(ùíü, Dict(R => table))
end

# The surface integral ‚à´fdA over a 2D geometry can be
# expressed as ‚à´·µ§‚à´·µ•f(u,v)||r·µ§√ór·µ•||dudv where the vector
# r = [x(u,v), y(u,v), z(u,v)] lives on the geometry and
# where r·µ§ = ‚àÇr/‚àÇu and r·µ• = ‚àÇr/‚àÇv are partial derivatives
# with respect to parameters u and v.
#
# For triangles, we can approximate functions linearly
# as f(u,v) = Œ∏‚ÇÄ + Œ∏‚ÇÅu + Œ∏‚ÇÇv using the values at the
# three vertices. This is a 3x3 linear system with
# analytical solution hard-coded below:
#
# |1 0 0| |Œ∏‚ÇÄ|   |f‚ÇÅ|
# |1 1 0| |Œ∏‚ÇÅ| = |f‚ÇÇ|
# |1 0 1| |Œ∏‚ÇÇ|   |f‚ÇÉ|
#
# Œ∏‚ÇÄ = f‚ÇÅ, Œ∏‚ÇÅ = f‚ÇÇ-f‚ÇÅ, Œ∏‚ÇÇ = f‚ÇÉ-f‚ÇÅ
#
# f(u,v) = f‚ÇÅ + (f‚ÇÇ-f‚ÇÅ)u + (f‚ÇÉ-f‚ÇÅ)v
#
# Coordinate functions can be approximated with the same
# system of equations (isometric approximation):
#
# x(u,v) = x‚ÇÅ + (x‚ÇÇ-x‚ÇÅ)u + (x‚ÇÉ-x‚ÇÅ)v
# y(u,v) = y‚ÇÅ + (y‚ÇÇ-y‚ÇÅ)u + (y‚ÇÉ-y‚ÇÅ)v
# z(u,v) = z‚ÇÅ + (z‚ÇÇ-z‚ÇÅ)u + (z‚ÇÉ-z‚ÇÅ)v
#
# Consequently, we have the following constant:
#
# r·µ§ = [(x‚ÇÇ-x‚ÇÅ), (y‚ÇÇ-y‚ÇÅ), (z‚ÇÇ-z‚ÇÅ)]
# r·µ• = [(x‚ÇÉ-x‚ÇÅ), (y‚ÇÉ-y‚ÇÅ), (z‚ÇÉ-z‚ÇÅ)]
#
# ||r·µ§√ór·µ•|| = ||(p‚ÇÇ-p‚ÇÅ)√ó(p‚ÇÉ-p‚ÇÅ)|| = c
#
# where p‚ÇÅ, p‚ÇÇ and p‚ÇÉ are the three vertices.
#
# Finally, for the limits of integration u ‚àà [0,1]
# and v ‚àà [0,1-u] we can solve the integrand as:
#
# ‚à´·µ§(‚à´·µ•f(u,v)dv)dv = ‚à´·µ§(f‚ÇÅ(1-u) + (f‚ÇÇ-f‚ÇÅ)u(1-u) + (f‚ÇÉ-f‚ÇÅ)(1-u)¬≤/2)du
#                  = ‚à´·µ§((f‚ÇÅ+f‚ÇÉ)/2 + (f‚ÇÇ-f‚ÇÉ-f‚ÇÅ)u + (f‚ÇÅ+f‚ÇÉ-2f‚ÇÇ)u¬≤/2)du
#                  = (f‚ÇÅ+f‚ÇÉ)/2 + (f‚ÇÇ-f‚ÇÉ-f‚ÇÅ)/2 + (f‚ÇÅ+f‚ÇÉ-2f‚ÇÇ)/6
#                  = (f‚ÇÅ+f‚ÇÇ+f‚ÇÉ)/6
#
# which leads to:
#
# ‚à´·µ§‚à´·µ•f(u,v)||r·µ§√ór·µ•||dudv = c(f‚ÇÅ+f‚ÇÇ+f‚ÇÉ)/6
function _integrateface(face::Connectivity{<:Triangle}, vert, vals)
  i, j, k = indices(face)
  p·µ¢, p‚±º, p‚Çñ = vert[[i, j, k]]
  c = ustrip(norm((p‚±º - p·µ¢) √ó (p‚Çñ - p·µ¢)))
  [c * (f[i] + f[j] + f[k]) / 6 for f in vals]
end

# fallback method ignores geometry and simply averages
# values of the variables at the vertices
function _integrateface(face, vert, vals)
  inds = collect(indices(face))
  [mean(val[inds]) for val in vals]
end
